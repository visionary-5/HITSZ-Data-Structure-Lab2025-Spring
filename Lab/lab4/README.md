# HITSZ 数据结构实验四: 查找与图应用

## 一、布隆过滤器

### 题目描述

布隆过滤器（Bloom Filter）是一种空间效率高、查询速度快的概率型数据结构，用于快速判断一个元素是否可能存在于一个集合中。

#### 核心组成

- 一个二进制位数组（Bit Array）：初始所有位设为 0。
- 多个哈希函数：用于将元素映射到位数组的不同位置。

#### 工作流程

##### 插入元素

- 对元素进行 k 次哈希计算，得到 k 个不同的位置。
- 将这些位置的位设为 1 。

##### 查询元素

- 对元素进行 k 次哈希计算，检查所有对应位置是否都为 1 ：
  - 如果所有位都是 1 → 可能存在（可能有误判）。
  - 如果有任意一位是 0 → 一定不存在（100%准确）。

#### 题目要求

初始代码已定义好布隆过滤器结构体、初始化和释放代码以及输入输出代码，请你补充设置某一位、检查某一位、添加元素、检查元素、以及3个哈希函数的代码。

**思考：**

- 为什么会发生误判？
- 布隆过滤器能否删除一个元素？

### 输入描述

第一行为一个数字 m ，代表接下来有 m 个待插入的元素  
接下来 m 行，每行表示一个元素  
一个数字 n ，代表接下来有 n 个待检查的元素  
接下来 n 行，每行表示一个元素  

### 输出描述

n 行，每行输出 1 或 0 ，表示检查的元素是否存在

### 示例输入

```c
3
apple
banana
orange
3
apple
banana
grape
```

### 示例输出

```c
1
1
0
```

## 二、二维矩阵查找

### 题目描述

给定一个 m*n 的二维矩阵 matrix ，该矩阵具有如下特性：

- 每行的元素从左到右递增；
- 每列的元素从上到下递增。

给定一个目标数值 target ，请你判断这个数值 target 是否存在于二维矩阵 matrix 中。

要求： 尽可能地降低时间复杂度。

### 输入描述

第一行输入两个数字 m 和 n  
紧接着 m 行，每行 n 个数字  
一个数字 K ，表示接下来有 K 个测试数字  
一行 K 个数，每个数字表示一个查找目标 target  

### 输出描述

K 行，每行输出 true 表示存在，false 表示不存在

### 示例输入

```c
3 4
1 4 7 10
2 5 8 11
3 6 9 12
4
6 0 10 13
```

### 示例输出

```c
true
false
true
false
```

## 三、迷宫求解

### 题目描述

设计一个迷宫求解程序，要求机器人在迷宫中首先找到钥匙，然后从钥匙位置找到出口。输入迷宫的格式如下：

第一行为两个整数 a 和 b，表示迷宫有 a 行 b 列。  
接下来 a 行提供迷宫的具体布局，其中：

- '0' 表示可通行路径，
- '1' 表示不可通行的墙，
- '*' 表示机器人的起始位置，
- '$' 表示钥匙位置，
- '#' 表示出口位置。

#### 要求

- 机器人只能沿着上下左右方向移动，不允许对角移动。
- 使用**深度优先搜索（DFS）**策略寻找钥匙。探索顺序固定为：右（R）、下（D）、左（L）、上（U）。
- 输出每次移动的方向，若遇到回退情况，也需输出回退的方向。找到钥匙时输出搜索策略所找到的从起始位置到钥匙的最短路径步数。
- 从钥匙位置开始，使用A*算法寻找出口路径。输出每次扩展的点的坐标，并在找到出口时输出路径中的所有坐标点。
- 结点 (x,y) 的代价函数为 f(x,y)=g(x,y)+h(x,y) ，其中：
  - g(x,y) 设为从钥匙位置到当前点已走过的步数。
  - h(x,y) 设为当前点与出口位置的曼哈顿距离，即 h(x,y) = |当前点的x - 出口位置x| + |当前点的y - 出口位置y|。
- 若代价函数值相同，优先选择x值更大者，x值相同则选择y值更大者。

### 输出描述

第一行输出DFS每次移动的方向，若遇到回退情况，也需输出回退方向。  
第二行输出DFS所找到的从起始位置到钥匙的最短路径步数。  
第三行输出使用给定代价函数的A*算法每次扩展的点的坐标。  
第四行输出A*算法所找到的路径中的所有坐标点。  
输出的方向以及坐标之间不要输出空格  

### 示例输入

```c
6 5
*0000
01110
01011
$0000
11010
1001#
```

### 示例输出

```c
->R->R->R->R->D->U->L->L->L->L->D->D->D
3
->(3,0)->(3,1)->(3,2)->(4,2)->(5,2)->(3,3)->(3,4)->(4,4)->(5,4)
->(3,0)->(3,1)->(3,2)->(3,3)->(3,4)->(4,4)->(5,4)
```

## 四、图的属性

### 题目描述

#### 实验内容

(1) 判断车站的路线图是否连通。从一个顶点开始遍历，如果能遍历到所有站点，那么图连通。

(2) 计算图中节点的度（degree）。
  节点度，是指和该站点相关联的边的条数。

(3) 计算图的聚类系数（clustering coefficient）。
  点的聚类系数是所有与它相连的顶点之间所连的边的数量，除以这些顶点之间可以连出的最大边数。图的聚类系数是所有点的聚类系数的均值。

(4) 若图连通，使用Dijkstra算法计算从某个站点到另一站点的最小票价。

(5) 若图连通，计算图的直径（diameter），半径（radius）。定义如下：

- 节点距离：指的是两个节点间的最短路径的长度。
- Eccentricity：这个参数描述的是从任意一个节点，到达其他节点的最大距离
- Diameter：图中的最大的Eccentricity
- Radius：图中的最小的Eccentricity

### 输入描述

```c
7 // 节点数
8 // 节点相邻边数
0 6 1 ////节点0到节点6有一条长度为1的边
1 6 2
1 2 3
2 3 4
3 4 5
4 6 6
4 5 7
1 3 8
```

### 输出描述

```c
connected: 1
degree distribution:
node0:1,node1:3,node2:2,node3:3,node4:3,node5:1,node6:3,
clustering coefficient:0.238095
the minimum fare between 1 and 3: 7
Path: 1->2->3
diameter:16
radius:9
```
